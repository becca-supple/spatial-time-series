# version of WGCM_fix from He et al. (2025) that takes residuals as input.
# He, Z., Pogodin, R., Li, Y., Deka, N., Gretton, A., and Sutherland, D. J. (2025). On the hardness of conditional independence testing in practice. Pre-print.

WGCM_fix <- function(resid.XonZ, resid.YonZ, Z, k0, nsim = 499){
  
  ###
  # Get dimensions of Z
  ###
  Z <- as.matrix(Z)
  n <- nrow(Z)
  dZ <- ncol(Z)
  
  ###
  # Construct a matrix of weight function values
  ###
  
  #Starting with w(z) = 1
  W <- rep(1, n)
  
  #Quantiles given k0 value
  quants <- seq(1, k0)/(k0 + 1)
  
  #Calculate weights for each quantile for each dimension of Z
  for(d in seq(1, dZ)){
    
    #Get z and a values
    Z_d <- Z[,d]
    a_values <- stats::quantile(Z_d, quants, names = FALSE)
    
    #Return value of sign function
    W_d <- outer(Z_d, a_values, function(x, a){
      return(sign(x - a))
    })
    
    #Add to W
    W <- cbind(W, W_d)
  }
  
  #Calculate weighted residual product
  R <- resid.XonZ * resid.YonZ * W
  R <- t(R)
  
  #Normalize
  R_norm <- R / sqrt(rowMeans(R^2) - rowMeans(R)^2)
  
  #Calculate test stat
  test.statistic <- sqrt(n) * max(abs(rowMeans(R_norm))) 
  
  #Null
  test.stat.null <- apply(abs(R_norm %*% matrix(rnorm(n*nsim), n, nsim)), 2, max) / sqrt(n)
  
  #Calculate p
  p.value <- (sum(test.stat.null >= test.statistic) + 1)/(nsim + 1)
  
  #Return
  return(list(test.statistic = test.statistic, p.value = p.value))
  
}
